/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   exercice_exam_rank_2                               :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: dsoum <dsoum@student.42.fr>                +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2024/03/07 15:29:49 by dsoum             #+#    #+#             */
/*   Updated: 2024/03/07 21:18:15 by dsoum            ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */


ALPHA_MIRROR;
/* le but est de remplacer les lettre dans un string de la façon suivante :
a devient z, m devient m, idem pour les ;ujuscule
trouver le pivot qui m et n donc m = 109 et n = 110 == 219
M = 77 et N = 78 == 155 */
#include <unistd.h>

int main(int ac, char **av)
{
	int i = 0;

	if(ac == 2)
	{
		while(av[1][i])
		{
			if (av[1][i] >= 'a' && av[1][i] <= 'z')
				av[1][i] = 219 - av[1][i];

			else if (av[1][i] >= 'A' && av[1][i] <= 'Z')
				av[1][i] = 155 - av[1][i];

			write(1, &av[1][i++], 1);
		}

	}
	write(1, "\n", 1);
	return (0);
}

ATOI;
/*la fonction atoi a pour but de transformer une string en entier*/

int ft_atoi(const char *str)
{
	int i = 0;
	int res = 0;
	int sign = 1;

	while (str[i] == ' ' || (str[i] >= 9 && str[i] <= 13))
		str++;
	if (str[i] == '-')
		sign = -1;
	if (str[i] == '+' || str[i] == '-')
		str++;
	while (str[i] >= '0' && str[i] <= '9')
	{
		res = res * 10 + str[i] - '0';
		i++;
	}
	return( sign * res);
}
#include <stdio.h>
#include <stdlib.h>

int ft_atoi(const char *str);

int	main()
{	char str1[] = "123";
	char str2[] = "-456";
	char str3[] = "0";
	char str4[] = "999999999";
	char str5[] = "-2147483648";
	char str6[] = "2147483647";

	printf("'%s' converti en int : %d\n", str1, ft_atoi(str1));
	printf("'%s' converti en int : %d\n", str2, ft_atoi(str2));
	printf("'%s' converti en int : %d\n", str3, ft_atoi(str3));
	printf("'%s' converti en int : %d\n", str4, ft_atoi(str4));
	printf("'%s' converti en int : %d\n", str5, ft_atoi(str5));
	printf("'%s' converti en int : %d\n", str6, ft_atoi(str6));
	return 0;
}

CAMEL_TO_SNAKE;
/*le but est de transformer une string ecrite en case camel en snake case>
donc ont doit separer les mot par un '_' et supprimer les mujuscule*/

#include <unistd.h>

int main(int ac, char **av)
{
	int i = 0;

	if (ac == 2)
	{
		while (av[1][i])
		{
			if (av[1][i] >= 'A' && av[1][i] <= 'Z')
			{
				write(1, "_", 1);
				av[1][i] += 32;
			}
			write(1, &av[1][i], 1);
			i++;
		}

	}
	write(1, "\n", 1);
	return (0);
}

DO_OP;
/* le but est de gerer l'ensemble des operateur arithmetique
le 1arg et le 3arg sont des entiers ne base 10 et le 2arg est l operateur + -  * / % */

#include <stdio.h>
#include <stdlib.h>

int main(int ac, char **av)
{
	if(ac == 4)
	{
		if (av[2][0] == '+')
			printf ("%d", (atoi(av[1])) + (atoi(av[3])));
		if (av[2][0] == '-')
			printf ("%d", (atoi(av[1])) - (atoi(av[3])));
		if (av[2][0] == '*')
			printf ("%d", (atoi(av[1])) * (atoi(av[3])));
		if (av[2][0] == '/')
			printf ("%d", (atoi(av[1])) / (atoi(av[3])));
		if (av[2][0] == '%')
			printf ("%d", (atoi(av[1])) %  (atoi (av[3])));
	}
	printf("\n");
	return(0);
}

FT_STRCMP;

/*le but est de comperer deux string et de retourner la difference entre les deux*/

int	ft_strcmp(const char *s1, const char *s2)
{
	int	i = 0;

	while(s1[i] && s2[i] && s1[i] == s2[i])
		i++;
	return ((unsigned char)s1[i] - (unsigned char)s2[i]);
}

FT_STRCSPN;

/*la fct calcule la longueur du segement initial de s qui ne contient que des octet
absent de reject.
elle renvoie le nbr d octet du segment initial de s.*/

#include <stdlib.h>

size_t  ft_strcspn(const char *s, const char *reject)
{
	size_t i = 0;
	size_t j;

	while(s[i])
	{
		j = 0;
		while(reject[j])
		{
			if (s[i] == reject[j])
				return (i);
			j++;
		}
		i++; 
	}
	return (i);// je retourne la taille de *s donc son index i
}

#include <stdio.h>
#include <string.h>
#include <stddef.h>

size_t ft_strcspn(const char *s, const char *reject);

int main(void)
{
	char str1[] = "Hello world";
	char str2[] = "Hello";
	char str3[] = "world";
	char str4[] = "12345";
	char str5[] = "67890";
	char str6[] = "1234567890";
	char reject1[] = " ";
	char reject2[] = "lo";
	char reject3[] = "789";

	printf("ft_strcspn: %zu\n", ft_strcspn(str1, reject1));
	printf("strcspn: %zu\n", strcspn(str1, reject1));

	printf("ft_strcspn: %zu\n", ft_strcspn(str1, reject2));
	printf("strcspn: %zu\n", strcspn(str1, reject2));

	printf("ft_strcspn: %zu\n", ft_strcspn(str1, reject3));
	printf("strcspn: %zu\n", strcspn(str1, reject3));

	printf("ft_strcspn: %zu\n", ft_strcspn(str2, str3));
	printf("strcspn: %zu\n", strcspn(str2, str3));

	printf("ft_strcspn: %zu\n", ft_strcspn(str4, str5));
	printf("strcspn: %zu\n", strcspn(str4, str5));

	printf("ft_strcspn: %zu\n", ft_strcspn(str6, reject3));
	printf("strcspn: %zu\n", strcspn(str6, reject3));

	return 0;
}

FT_STRDUP;
/*renvoie un pointeur sur une nouvelle chaine de caractere qui est duplique depuis src.
la memmoire occupe par cette nouvelle chaine est obtemur en appelant malloc.*/

#include <stdlib.h>
#include <stdio.h>

char	*ft_strdup(char *src)
{
	char	*dest;
	int	 i = 0;

	while (src[i])
		i++;
	dest = malloc(sizeof (char) * (i + 1));
	if(!dest)
		return (NULL);
	i = 0;
	while (src[i])
	{
		 dest[i] = src[i];
		 i++;
	}
	dest[i] = '\0';
	return (dest);
}


int main(void)
{
	char *src = "Hello world!";
	char *dup = ft_strdup(src);

	if (dup == NULL)
	{
		printf("Erreur : échec de l'allocation mémoire.\n");
		return 1;
	}

	printf("La chaîne originale est : %s\n", src);
	printf("La chaîne dupliquée est : %s\n", dup);

	free(dup);
	return 0;
}

FT_STRREV;
/* la fct inverse l ordre des caractere dans une string*/

#include <stdlib.h>

char	*ft_strrev(char *str)
{
	char	*start;
	char	*end;
	char	temp;

	if(!str)
		return (NULL);

	start = str;
	end = str;

	while(*end)
		end++;
	end--;

	while(start < end)
	{
		temp = *start;
		*start = *end;
		*end = temp;
		start++;
		end--;
	}
	return (str);
}

#include <stdio.h>


char	*ft_strrev(char *str);

int	main()
{
	char str[] = "Hello World";
	printf("Original string: %s\n", str);
	ft_strrev(str);
	printf("Reversed string: %s\n", str);
	return (0);
}

FT_STRSPN;

/* calcule la longeur initial de s qui contient que des octet present dans accepte
on retourne la taille de s*/

#include <stdlib.h>

size_t  ft_strspn(const char *s, const char *accept)
{
	size_t  i = 0;
	size_t  j;

	while (s[i])
	{
		j = 0;
		while (accept[j])
		{
			if (s[i] == accept[j])
				break;
			j++;
		}
		if (accept[j] == '\0')
			return (i);
		i++;
	}
	return (i);//je retourne la taille de *s donc l index i

}

#include <stdio.h>
#include <string.h>

size_t	ft_strspn(const char *s, const char *accept);

int main(void)
{
	const char *s = "Hello, world!";
	const char *accept = "eloH wrd";

	size_t ft_result = ft_strspn(s, accept);
	size_t std_result = strspn(s, accept);

	printf("ft_strspn result: %zu\n", ft_result);
	printf("strspn result: %zu\n", std_result);

	if (ft_result == std_result)
		printf("Both functions returned the same result.\n");
	else
		printf("The results differ.\n");

	return 0;
}

INTER;

/*le but est de comparer deux string et de chercher les occurances dans l ordre
d'aparition sans doublon*/

#include <unistd.h> // Pour la fonction write

int main(int ac, char **av)
{
	if (ac == 3)
	{
		char *s1 = av[1];
		char *s2 = av[2];
		int found[256] = {0}; // Tableau pour marquer les caractères trouvés

		// Marquer les caractères de s2 comme trouvés dans le tableau
		for (int i = 0; s2[i] != '\0'; i++)
		{
			found[(unsigned char)s2[i]] = 1;
		}

		// Parcourir s1 et écrire les caractères communs non répétés dans s2
		for (int i = 0; s1[i] != '\0'; i++)
		{
			if (found[(unsigned char)s1[i]] == 1)
			{
				write(1, &s1[i], 1);
				found[(unsigned char)s1[i]] = 0; // Pour éviter la répétition
			}
		}
	}

	write(1, "\n", 1);
	return 0;
}

IS_POWER_OF_2;
/*fct qui verifie si le nbr est une puyissance de 2*/

int is_power_of_2(unsigned int n)
{
	if(n == 0)// si mon nbr est == a zero ce n est pas une puissance de 2
		return (0);

	while (n > 1)//tant que mon nbr est strictement sup a 1
	{
		if (n % 2 == 0)// si le reste de la divion du n par 2 est == a zero c est une puissance de 2
			n /= 2;//je divise le nbr par 2
		else
			return (0);// sinon ce n est pas une puissance donc retourne 0 pour faux
	}
	return (1);// dans ce cas le nbr est une puissance donc je retourne 1 pour vrai
}
#include <stdio.h>

int is_power_of_2(unsigned int n);

int main(void)
{
	unsigned int n;
	printf("Entrez un entier positif : ");
	scanf("%u", &n);
	if (is_power_of_2(n))
		printf("%u est une puissance de 2.\n", n);
	else
		printf("%u n'est pas une puissance de 2.\n", n);
	return 0;
}

LAST_WORD;

/*le but est d extraire et ecrire le dernier mot d une string*/

#include <unistd.h>

int	main(int ac, char **av)
{
	int	i = 0;

	if (ac == 2)
	{
		 while (av[1][i])//je parcours la string jusqu a la  fin
		 	i++;

		while (--i && (av[1][i]) == ' ' || av[1][i] =='\t')
		//je suis a la fin de la string et j ignore les esp et les tab
			;

		while(i && av[1][i] != ' ' && av[1][i] != '\t')
		// je suis a lafin du dernier mot et je decremente tant que j ai pas d esp ou de tab
			i--;

		if (av[1][i] == ' ' || av[1][i] == '\t')
		// je trouve le debut de dernier mot en avançant tant que c est des esp et des tab
			i++;

		while (av[1][i] && av[1][i] != ' ' && av[1][i] != '\t')
			// tant que ma string existe et qu je n est pas d esp ou de tab
			write(1, &av[1][i++], 1);// j ecrit le dernier mot
	}
	write(1, "\n", 1);
	return (0);
}

MAX;
/* le but est de trouver la valeur max dans un tableau d entier
on retourne le resultat*/

#include <stdlib.h>

int	 max(int* tab, unsigned int len)
{
	int res;// res represente la valeur max que l on retourne
	unsigned int i;

	if(len == 0 || tab == NULL)
		return (0);

	res = tab[0];
	i = 1;

	while (i < len)
	{
		if (res < tab[i])
			res = tab[i];
		i++;
	}
	return (res);
}

PRINT_BITS;
/*affiche les bits*/
#include <unistd.h>

void	print_bits(unsigned char octet)
{
	int i = 7;

	while (i >= 0)
	{
		if ((octet >> i) & 1)
			write(1, "1", 1);
		else
			write(1, "0", 1);
		i--;
	}
}

#include <unistd.h>

void	print_bits(unsigned char octet);

int	main(void)
{
	print_bits(2);
	return (0);
}

REVERSE_BITS;
/*inverser l ordre des bits*/
#include <stdio.h>

unsigned char   reverse_bits(unsigned char octet)
{
	int	 i = 0;
	int	 reverse = 0;

	while( i < 8)
	{
		reverse = (reverse << 1) | (octet & 1);
		octet >>= 1;
		i++;
	}
	return (reverse);
}

int	 main(void)
{
	unsigned char   octet = 0x41;
	unsigned char   reverse = reverse_bits(octet);

	printf("octet inverse : 0x%x\n", reverse);
	return(0);
}

SNAKE_TO_CAMEL;
/*le but est de remplacer la case snake par la case camel
supprimer les '_' dans la string et chaque mot doit commencer par une lettre majuscule*/

int	main(int ac, char **av)
{
	int	i = 0;

	if (ac == 2)
	{
		while(av[1][i])
		{
			if(av[1][i] == '-')// si mon caracter est un _
			{
				i++;// alors j avance au prochain caractere 
				av[1][i] -= 32;// et je transforme ce caractere en majuscule
			}
			write(1, &av[1][i++], 1);// j ecris ma string
		}
	}
	write(1, "\n", 1);
	return (0);
}
SWAP_BITS;
unsigned char 	swap_bits(unsigned char octet)
{
	return ((octet >> 4) | (octet << 4));
}


#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>

unsigned char	swap_bits(unsigned char octet);

int main(void)
{
	unsigned char octet = 0x41;
	unsigned char swapped_octet = swap_bits(octet);

	printf("Octet original : 0x%02x\n", octet);
	printf("Octet échangé  : 0x%02x\n", swapped_octet);

	return (0);
}

UNION;
/*ce programme prend deux tring en entree et affiche sans doublon les caractere qui apparaissent
dans l'une ou l'autre des chaines. les caracterer affiche sont dans l ordre d apparition*/

#include <unistd.h> // Pour la fonction write

int main(int ac, char **av)
{
	int		i = 0;
	int		found[256] = {0};
	char	*s1 = av[1];
	char	*s2 = av[2];

	if (ac == 3)
	{
		for(i = 0; s1[i] != '\0'; i++)
		{
			if(found[(unsigned char) s1[i]] == 0)
			{
				found[(unsigned char) s1[i]] = 1;
				write(1, &s1[i], 1);
			}
		}
		for(i = 0; s2[i] != '\0'; i++)
		{
			if(found[(unsigned char) s2[i]] == 0)
			{
				found[(unsigned char) s2[i]] = 1;
				write(1, &s2[i],1);
			}
		}

	}

	write(1, "\n", 1);
	return 0;
}

WDMATCH;
/*verifier si la string 1 est contenue dans la string 2 et si oui on ecrit la string 1*/

#include <unistd.h>

int	 main(int ac, char **av)
{
	int i = 0;
	int j = 0;

	if (ac == 3)
	{
		while(av[1][i] && av[2][j])
		{
			if (av[1][i] == av[2][j])
					i++;
			j++;
		}
		if(av[1][i] =='\0')
		{
			i = 0;
			while(av[1][i])
			{
				write(1, &av[1][i], 1);
				i++;
			}
		}
	}
	write(1, "\n", 1);
	return (0);
}

LCM;
/*fonction qui retourne le plus petit denominateur commun */

#include <stdio.h>

unsigned int pgcd(unsigned int nb1, unsigned int nb2)
{
	while (nb2 != 0)
	{
		unsigned int temp = nb2;
		nb2 = nb1 % nb2;
		nb1 = temp;
	}
	return (nb1);
}

unsigned int lcm(unsigned int nb1, unsigned int nb2)
{
	if (nb1 == 0 || nb2 == 0)
		return (0);
	return (nb1 * nb2) / pgcd(nb1, nb2);
}


int main(void)
{
	unsigned int a, b;
	unsigned int result;

	// Test case 1
	a = 12;
	b = 18;
	result = lcm(a, b);
	printf("LCM of %u and %u is %u\n", a, b, result);

	// Test case 2
	a = 7;
	b = 13;
	result = lcm(a, b);
	printf("LCM of %u and %u is %u\n", a, b, result);

	// Test case 3
	a = 0;
	b = 5;
	result = lcm(a, b);
	printf("LCM of %u and %u is %u\n", a, b, result);

	// Test case 4
	a = 16;
	b = 0;
	result = lcm(a, b);
	printf("LCM of %u and %u is %u\n", a, b, result);

	return (0);
}

PGCD;
/*programme qui permet d afficher le plus grand denominateur commun*/

#include <stdlib.h>
#include <stdio.h>

int	main(int ac, char **av)
{
	if(ac == 3)
	{
		int	nb1 = atoi(av[1]);
		int	nb2 = atoi(av[2]);
		int 	swap;

		while(nb2 != 0)
		{
			swap = nb2;
			nb2 = nb1 % nb2;
			nb1 = swap;
		}
		printf("%d", nb1);
	}
	printf("\n");
	return (0);
}

ADD_PRIME_SUM;
/* le but est de savoir si un nbr est nbr premier
un nbr premier est un nbr divisible par 1 et par lui-meme
attention 1 n est pas un nbr premier */

#include <unistd.h>

void	ft_putnbr(int nbr)
{
	char c;

	if(nbr >= 10)
		ft_putnbr(nbr / 10);
	c = nbr % 10 + '0';
	write(1, &c, 1);
}

int	 ft_atoi(char *str)
{
	int res = 0;
	int i = 0;

	while (str[i])
	{
		res = res * 10 + str[i] - '0';
		i++;
	}
	return (res);
}
int	 is_prime(int nbr)
{
	if( nbr <= 1)
		return (0);

	for (int i = 0; i * i <= nbr; i++)
	{
		if (nbr % i == 0)
			retrun (0);
	}
	return (1);
}

int	 main(int ac, char ** av)
{
	if(ac != 2)
	{
		write(1, "\n", 1);
		return(0);
	}

	int limit = ft_atoi(av[1]);

	if(limit <= 0)
	{
		write(1, "\n", 1);
		return (0);
	}

	int sum = 0; //sum = somme => res

	for(int i = 2; i <= limit; i++)
	{
		if(is_prime(i))
			sum += 1;
	}
	ft_putnbr(sum);
	write(1, "\n", 1);
	return (0);
}

EPUR_STR;
/*supprimer les esp  et tab  en trop*/

#include <unistd.h>

int main(int ac, char **av)
{
	int	i = 0;
	int	space = 0;

	if (ac == 2)
	{
		while (av[1][i] == ' ' || av[1][i] == '\t')
			i++;

		while (av[1][i])
		{
			if (av[1][i] == ' ' || av[1][i] == '\t')
				space = 1;

			if (av[1][i] != ' ' && av[1][i] != '\t')
			{
				if (space)
					write(1, " ", 1);
				space = 0;
				write(1, &av[1][i], 1);
			}
			i++;
		}
	}
	write(1, "\n", 1);
	return (0);
}

EXPEND_STR;
/*ecrire 3 esp entre les mots*/

#include <unistd.h>

int main(int ac, char **av)
{
	int	i = 0;
	int	space;

	if (ac == 2)
	{
		while (av[1][i] == ' ' || av[1][i] == '\t')
			i++;

		while (av[1][i])
		{
			if (av[1][i] == ' ' || av[1][i] == '\t')
				space = 1;

			if (av[1][i] != ' ' && av[1][i] != '\t')
			{
				if (space)
					write(1, "   ", 3);
				space = 0;
				write(1, &av[1][i], 1);
			}
			i++;
		}
	}
	write(1, "\n", 1);
	return (0);
}

FT_ATOI_BASE;
/*idem que atoi mais en base hexadecimal*/

int	 ft_atoi_base(const char *str, int str_base)
{
	int	 res = 0;
	int	 sign = 1;
	int	 i = 0;

	if(str_base >= 2 || str_base <= 16)
	{
		while (str[i] == ' ' || (str[i] >= 9 && str[i] <= 13))
			str++;
		if (str[i] == '-')
			sign = -1;
		if (str[i] == '-' || str[i] == '+')
			str++;
		while (str[i])
		{
			if(str[i] >='0' && str[i] <= '9')
				res = res * str_base + str[i] - '0';
			else if (str[i] >= 'a' && str[i] <= 'f')
				res = res * str_base + str[i] - 'a' + 10;
			else if ( str[i] >= 'A' && str[i] <= 'F')
				res = res *str_base + str[i] - 'A' + 10;
			else
				break;
			i++;
		}
	}
	return (sign * res);
}
#include <stdio.h>
#include <stdlib.h>

int ft_atoi_base(const char *str, int str_base);

int main()
{
	printf("%d\n", ft_atoi_base("1010", 2)); // attendu : 10
	printf("%d\n", ft_atoi_base("a", 16)); // attendu : 10
	printf("%d\n", ft_atoi_base("-1010", 2)); // attendu : -10
	printf("%d\n", ft_atoi_base("z123", 16)); // attendu : 0
	printf("%d\n", ft_atoi_base("1010", 1)); // attendu : 0
	return (0);
}

FT_LIST_SIZE;
/*la fct doit calculer la taille d une liste chainer avec l aide d une sturcture*/

#include <stdlib.h>

typedef struct	s_list
{
	struct s_list *next;
	void	*data;
}	t_list;

int	ft_list_size(t_list *begin_list)
{
	if (begin_list == NULL)
		return (0);
	else
		return (ft_list_size(begin_list->next) + 1);
}

FT_RANGE;
/*le tableau est rempli avec les valeurs consecutive commençant a start et se terminant a end en les incluant.*/

#include <stdlib.h>
#include <stdio.h>

int	*ft_range(int start, int end)
{
	int	i = 0;//index pour parcourir le tableau
	int	size;// var pour stoker la taille
	int	*tab;//pointeur vers un tableau d entier

	if(start > end)// odre decroissant
		size = start - end + 1;
	else// orde croissant
		size = end - start + 1;

	tab = malloc(sizeof(int) * size);
	if(!tab)
		return (NULL);

	while(i < size)//boucle pour remplir le tableau
	{
		if(start <= end)
			tab[i] = start++;
		else
			tab[i] = start--;
		i++;
	}
	return (tab);
}
int	main(void)
{
	int	*range;
	int	i;

	range = ft_range(1, 3);
	i = 0;
	while (i < 3)
	{
		printf("%d ", range[i]);
		i++;
	}
	printf("\n");
	free(range);
	return (0);
}

FT_RRANGE;
/*le fct prend deux entiers en argument start et end et renvoie un pointeur vers un tableau
aloue dynamiquement.
le tableau est rempli avec les valeurs consecutive commençant a end et se terminant a start en les incluant.*/

#include <stdio.h>
#include <stdlib.h>

int	*ft_rrange(int start, int end)
{
	int	i = 0;//index pour parcourir le tableau d entier
	int	size;// var pour stocker la taille du tableau
	int	*tab;// pointeur  vers le tableau d entier

	if( start > end)
		size = start - end + 1;
	else
		size = end - start + 1;

	tab = malloc(sizeof(int) * size);
	if(!tab)
		return (NULL);

	while(i < size)
	{
		if (start <= end)
			tab[i] = end ++;
		else
			tab[i] = end --;
		i++;
	}
	return (tab);
}

int main()
{
	int *arr;
	int i;

	arr = ft_rrange(1, 3);
	printf("Array: ");
	for (i = 0; i < 3; i++)
		printf("%d ", arr[i]);
	printf("\n");
	free(arr);
	return 0;
}

HIPEND;
/*programme qui permet de savoir si une sous chaine s1 est presente dans la chaine s2
elle doit apparaitre dans le meme ordre
si s1 est contenue dans s2 alors on ecrit 1 sinon on ecrit 0*/

#include <unistd.h>

int	main(int ac, char **av)
{
	int	i = 0; // index pour parcourir av[1]
	int	j = 0; // index pour parcourir av[2]

	if(ac == 3)
	{
		while ( av[1][i] && av[2][j])
		{
			if (av[1][i] == av[2][j])// si le caractere s1 et compris dans s2
				i++;// j avance  dans av[1]
			j++;//j'avance dans av[2]
		}
		if (av[1][i] == '\0')// si j arrire a la fin ce la chaine av[1] alors tout les caractere ont ete trouve
			write(1, "1", 1);// alors dans ce cas j ecrai 1
		else   // sinon j ecris 0
			write(1, "0", 1);
	}
	write(1, "\n", 1);
	return (0);
}

PARAMSUM;
/*afficher le nom du programme*/

#include <unistd.h>

void	ft_putnbr(int nbr)
{
	char	c;

	if(nbr >= 10)
		ft_putnbr(nbr / 10);
	c = nbr % 10 + '0';
	write(1, &c, 1);
}

int	main(int ac, char **av)
{
	(void)av;

	if (ac == 1)
		write(1, '\n', 1);
	else
		ft_putnbr(ac - 1);
	write(1, "\n", 1);
	return (0);
}

PRINT_HEXA;
/*programme pour afficher la sortie en hexadecimal*/

#include <unistd.h>

int	ft_atoi(char *str)
{
	int	res = 0;
	int	i = 0;

	while(str[i])
	{
		res = res * 10 + str[i] - '0';
		i++;
	}
	return (res);
}

void	print_hexa(int nbr)
{
	char c[] = "0123456789abcdef";

	if( nbr >= 16)
		print_hexa(nbr / 16);
	write(1, &c[nbr % 16], 1);
}

int	main(int ac , char **av)
{
	int nbr;

	if (ac != 2)
	{
		write(1, "\n", 1);
		return (0);
	}
	else if(ac == 2)
	{
		nbr = ft_atoi(av[1]);
		if (nbr >= 0)		   // si av[1] est positif
			print_hexa(nbr);
	}
	write(1, "\n", 1);
	return (0);
}

RSTR_CAPITALIZER;
/*les minuscule sont transformer em mininuscule sur la derniere lettre du mot
si un  mot ne contient q une seul lettre et qu elle est en majuscule elle reste en majuscule*/

#include <unistd.h>

int	main(int ac, char ** av)
{
	int	i = 1;// argument (mot de la string)
	int 	j;//index de l argument (index du caractere du mot)

	if ( ac == 1)//si il n y a pas d arg on ecrit le retour a la ligne
		write(1, "\n", 1);
	else
	{
		while(i < ac)// bouble qui arcours tout les arg
		{
			j = 0;
			while(av[i][j])
			{
				if (av[i][j] >= 'A' && av[i][j] <= 'Z')
					av[i][j] += 32;
				if ((av[i][j] >= 'a' && av[i][j] <= 'z') && (av[i][j + 1] == ' '
									|| av[i][j + 1] == '\t'
									|| av[i][j + 1] == '\0'))
					av[i][j] -= 32;
				write(1, &av[i][j++], 1);
			}
			write(1, "\n", 1);
			i++;
		}
	}
	return (0);
}

STR_CAPITALIZER;
/*chaque debut de mot doit etre en majuscule et le reste en minuscule*/
#include <unistd.h>

int	main(int ac, char **av)
{
	int	i = 1;//argument
	int	j;//index de l argument

	if(ac == 1)//si il n y a pas d arg ecrire le retour a la ligne
		write(1, "\n", 1);
	else
	{
		while(i < ac)//boucle pour parcourir tout les arg
		{
			j = 0;
			if(av[i][j] >= 'a' && av[i][j] <= 'z')
				av[i][j] -= 32;
			write(1, &av[i][j], 1);

			while(av[i][++j])//boucle qui pqrcours les caractere suivant de l arg
			{
				if (av[i][j] >= 'A' && av[i][j] <= 'Z')
					av[i][j] += 32;
				if ((av[i][j] >= 'a' && av[i][j] <= 'z') && (av[i][j - 1] == ' '
									 || av[i][j - 1] == '\t'
									 || av[i][j - 1] == '\0'))
					av[i][j] -= 32;
				write(1, &av[i][j], 1);
			}
			write(1, "\n", 1);
			i++;
		}
	}
	return (0);
}

TAB_MULT;
/*le but est d ecrire la table de multiplication */

#include <unistd.h>

void	ft_putnbr(int nbr)
{
	char	c;

	if (nbr >= 10)
		ft_putnbr(nbr / 10);
	c = nbr % 10 + '0';
	write(1, &c, 1);
}

int	ft_atoi(char *str)
{
	int res = 0;
	int i = 0;

	while (str[i])
	{		
		if (str[i] >= '0' && str[i]  <= '9')
		{
			res = res * 10 + str[i] - '0';
			i++;
		}
		else
			return (0);
	}
	return (res);
}
void	tab_mult(int nbr2)
{
	int  nbr1 = 1;// on commemce a 1 car on multiplie pas par 0

	while(nbr1 <= 9)
	{
		ft_putnbr(nbr1);
		write(1, " x ", 3);
		ft_putnbr(nbr2);
		write(1, " = ", 3);
		ft_putnbr(nbr1 * nbr2);
		write(1, "\n", 1);
		nb1++;
	}
}

int	main(int ac, char **av)
{	
	int nbr;
	
	if (ac != 2)
		write(1, "\n", 1);
	else if (ac == 2)
	{
		nbr = ft_atoi(av[1]);
		
		if (nbr == 0)
			return (0);
		else if (nbr >= 0)
			tab_mult(nbr);
	}
	return (0);
}

FLOOD_FILL;
/*le but est de remplis un tableau d axe x et y avec ce qu on veux dans ce cas 'F'*/
#include <stdio.h>
#include <stdlib.h>

typedef struct s_point
{
	int x;
	int y;
} t_point;

void	fill(char **tab, t_point size, t_point cur, char to_fill)
{
	//on verifie que les point x et y ne soit pas en dehors ou sur le bord du tableau a deux demansion
	if(cur.y < 0 || cur.x < 0 || cur.y >= size.y || cur.x >= size.x || tab[cur.y][cur.x] != to_fill)
			return;

	tab[cur.y][cur.x] = 'F';
//je rempli les case gauche droite haut et bas
	fill(tab, size, (t_point){cur.y - 1, cur.x}, to_fill);
	fill(tab, size, (t_point){cur.y + 1, cur.x}, to_fill);
	fill(tab, size, (t_point){cur.x - 1, cur.y}, to_fill);
	fill(tab, size, (t_point){cur.x + 1, cur.y}, to_fill);
}
void	flood_fill(char **tab, t_point size, t_point begin)
{
	fill(tab, size, begin, tab[begin.y][begin.x]);
}

FPRIME;
/* decomposition d un nbr en facteur premier chaque nbr est seraprer par '*' */

#include <stdlib.h>
#include <stdio.h>

int main(int ac, char **av)
{
	if (ac == 2)
	{
		int nbr = atoi(av[1]);
		int diviseur = 2;

		if (nbr <= 0)//on ne peut pas decomposer un nbr inf ou = a 0
		{
			printf("\n");
			return (0);
		}

		if (nbr == 1)// cas pour nbr = a 1
		{
			printf("1\n");
			return (0);
		}

		while (nbr != 1)
		{
			if (nbr % diviseur == 0) //c est un facteur premier
			{
				printf("%d", diviseur);
				nbr /= diviseur;//mise a jour du nbr en le divisant par le diviseur
				if (nbr != 1)
				{
					printf("*");
				}
			}
			else
			{
				diviseur++;
			}
		}
	}
	printf("\n");
	return 0;
}

FT_LIST_FOREACH;

// #include "ft_list.h"
 #include <stdlib.h>
 #include <stdio.h>

typedef struct	  s_list
{
	struct s_list   *next;
	void			*data;
}				   t_list;


 void   ft_list_foreach(t_list *begin_list, void (*f)(void *))
 {
		t_list *current = begin_list;

		while(current != NULL)
		{
			(*f)(current->data);

			current = current->next;
		}
 }
//current represente le pointeur vers l element courant de la list.

void print_int(void *data)
{
	printf("%d ", *(int*)data);
}

int main()
{
	t_list *list = NULL;
	int n1 = 10, n2 = 20, n3 = 30;
	list = malloc(sizeof(t_list));
	list->data = &n1;
	list->next = malloc(sizeof(t_list));
	list->next->data = &n2;
	list->next->next = malloc(sizeof(t_list));
	list->next->next->data = &n3;
	list->next->next->next = NULL;

	ft_list_foreach(list, print_int);
	printf("\n");

	free(list->next->next);
	free(list->next);
	free(list);

	return 0;
}

FT_LIST_REMOVE;

/*supprimer un noeud d une liste chainer si les data sont identique
donc il faut comperer le noeud entre eux*/

//#include "ft_list.h"
#include <stdlib.h>

typedef struct	  s_list
{
	struct s_list   *next;
	void			*data;
}				   t_list;

void	ft_list_remouv_if(t_list **begin_list, void *data_ref, int (*cmp)())
{
		if((begin_list == NULL) || (*begin_list == NULL))
			return;

		t_list  *current = *begin_list;

		if (cmp(current->data, data_ref) == 0)
		{
				*begin_list = current->next;
				free(current);
				ft_list_remouv_if(begin_list, data_ref, cmp);
		}
		current = *begin_list;
		ft_list_remouv_if(&current->next, data_ref, cmp);
}
FT_REV_WSTR;
/*le programme prend une chaine de caractere en parametre et affiche ses mots dans
l odre inverse, il ne doit pas avoir d espace suplementaire*/



#include <stdio.h>
#include <string.h>
#include <unistd.h>
#include <stdlib.h>

char	is_separator(char c)
{
	return ( c == ' ' || c == '\n' || c == '\t');
}
char	**ft_split(char *str)
{
	char	**tab;
	int		 mot = 0;
	int		 caractere_mot;

	tab = (char **)malloc(sizeof(char *) * 256);
	if(tab == NULL)
		return (NULL);

	while (*str)
	{
		while(is_separator (*str))
			str++;

		if(*str == '\0')
			break;

		caractere_mot = 0;

		tab[mot] = (char *)malloc(sizeof(char) * 4096);
		if (tab[mot] == NULL)
			return (NULL);

		while(*str && !is_separator(*str))
			tab[mot][caractere_mot++] = *str++;
	   // tab[mot][caractere_mot] = '\0';
		mot++;
	}
	tab[mot] = NULL;
	return (tab);
	}
int	ft_strlen(char *str)
{
	int i = 0;
	while(str[i])
		i++;
	return (i);
}

int main(int ac, char **av)
{
	int i = 0;

	if (ac == 2)
	{
		char **mots = ft_split(av[1]); // Split de la string
		if (mots == NULL)
		  return 1;

		// trouver le nbr de mots
		
		int count_mots = 0;
		
		while (mots[count_mots] != NULL)
			count_mots++;


		// Reverse and print les mot
		
		for (i = count_mots - 1; i >= 0; i--)
		{
			write(1, mots[i], ft_strlen(mots[i]));
			if (i > 0)
			{
				write(1, " ", 1);
			}
		}

		// Free memory 
		for (i = 0; i < count_mots; i++)
		{
			free(mots[i]);
		}
		free(mots);
	}
	write(1, "\n", 1);
	return 0;
}

FT_SPLIT;
/*fonction split separe chaque mot d une string, les stock separerment dans un tableau
a double entre (mot et caractere de chaque mot) et ecrit en sortie chaque mot separement*/

#include <stdlib.h>
#include <stdio.h>

char	is_separator(char c)
{
	return ( c == ' ' || c == '\n' || c == '\t');
}
char	**ft_split(char *str)
{
	char	**tab;
	int		 mot = 0;
	int		 caractere_mot;

	tab = (char **)malloc(sizeof(char *) * 256);
	if(tab == NULL)
		return (NULL);

	while (*str)
	{
		while(is_separator (*str))
			str++;

		if(*str == '\0')
			break;

		caractere_mot = 0;

		tab[mot] = (char *)malloc(sizeof(char) * 4096);
		if (tab[mot] == NULL)
			return (NULL);

		while(*str && !is_separator(*str))
			tab[mot][caractere_mot++] = *str++;
		tab[mot][caractere_mot] = '\0';
		mot++;
	}
	tab[mot] = NULL;
	return (tab);
	}
int main(int ac, char **av)
{
	int	i = 0;
	char	**tab;

	if (ac == 2)
	{
		tab = ft_split(av[1]);
		while (tab[i] != NULL)
		{
			printf("%s\n", tab[i]);
			free(tab[i]);
			i++;
		}
	}
	free(tab);
	return 0;
}

ITOA;


/*transforme des entiers en chaine de caractere inverse de atoi*/

#include	<stdlib.h>
#include	<stdio.h>

char	*ft_itoa(int nbr)
{
	int	 i = 0;
	int	 temp = nbr;
	char *str;

	if (nbr == -2147483648)
		return ("-2147483648");

	str = malloc(sizeof(char) * (i + 1));
	if(!str)
		return (NULL);

	str[i] ='\0';

	if (nbr == 0)
		return ("0");

	if (nbr < 0)
	{
		i++;
		nbr *= -1;
		str[0] = '-';
	}

	while (temp)
	{
		temp /= 10;
		i++;
	}

	while (nbr)
	{
		str[--i] = (nbr % 10) + '0';
		nbr /= 10;
	}
	return (str);

}

int main()
{
	int number = -12345;
	char *result = ft_itoa(number);

	if (result)
	{
		printf("Le nombre %d sous forme de chaîne est : %s\n", number, result);
		free(result); // N'oubliez pas de libérer la mémoire allouée
	}
	else
	{
		printf("Erreur lors de l'allocation mémoire.\n");
	}

	return 0;
}

ROSTRING;

/*le premier mot devient le dernier : rotation d un mot vers la gauche*/
#include <unistd.h>

int	 main(int ac, char **av)
{
		int	 i = 0;
		int	 start;
		int	 end;
		int	 space = 0; //on utilis uniquement a 1 lorsque on veut signaler un espace ou tab

		if(ac > 1 && av[1][0])//verifie s'il y a  plus d un arg et que la chaine n est pas vide
		{
			while (av[1][i] == ' ' || av[1][i] == '\t')
				i++;

			start = i;

			while (av[1][i] != ' ' && av[1][i] != '\t' && av[1][i] != '\0')
				i++;

			end = i;

			while (av[1][i] == ' ' || av[1][i] == '\t')
				i++;

			while(av[1][i])
			{
					while ((av[1][i] == ' ' && av[1][i + 1] == ' ')//je gere les esp et tab consecutif
											|| (av[1][i] == '\t'  && av[1][i + 1] == '\t'))
							i++;
					if (av[1][i] == ' ' || av[1][i] == '\t')

							space = 1;

					write(1, &av[1][i++],1);
			}
			if(space)
				write(1, " ", 1);

			while(start < end)
			{
				write(1, &av[1][start++], 1);
			}

		}
		write(1, "\n", 1);
		return(0);
}

SORT_IN_TAB;


/* trie a bulle : trie d un tableau d entier en ordre croissant*/

#include <stdio.h>

version 1:

void	sort_int_tab(int *tab, unsigned int size)
{
	for(unsigned int elem_trie = 0; elem_trie < size - 1; elem_trie++)
	{
		for(unsigned int a_trier = 0; a_trier < size - elem_trie - 1; a_trier++)
		{
			if(tab[a_trier] > tab[a_trier + 1])
			{
				int swap = tab[a_trier];
				tab[a_trier] = tab[a_trier + 1];
				tab[a_trier + 1] = swap;
			}
		}
	}
}

version 2:

void	sort_int_tab(int *tab, unsigned int size)
{
	unsigned int i = 0;
	int swap;

	while (i < (size -1))
	{
		if (tab[i] > tab[i + 1])
		{
			swap = tab[i];
			tab[i] = tab[i + 1];
			tab[tab + 1] = swap;
			i = -1;
		}
		i++;
	}
}

int main()
{
	int arr[] = {4, 2, 7, 1, 9, 3};
	unsigned int arr_size = sizeof(arr) / sizeof(arr[0]);

	printf("Avant le tri : ");
	for (unsigned int i = 0; i < arr_size; i++) {
		printf("%d ", arr[i]);
	}
	printf("\n");
	sort_int_tab(arr, arr_size);
	printf("Après le tri : ");
	for (unsigned int i = 0; i < arr_size; i++) {
		printf("%d ", arr[i]);
	}
	printf("\n");
	return 0;
}

SORT_LIST;


/*la fct a pour but de trier la list donnee selon l ordre specifier par la fct de comparaison et de renvoyer
un pointeur vers le premier element de la liste triee*/

//#include "list.h"
#include <stdlib.h>
#include <stdio.h>

typedef struct s_list t_list;

struct s_list
{
	int	 data;
	t_list  *next;
};

t_list  *sort_list(t_list *lst,int (*cmp)(int,int))
{
		int	 swap;
		t_list  *current = lst;

		while (current->next != NULL)
		{
				if(((*cmp)(current->data, current->next->data)) == 0)
				{
					swap = current->data;
					current->data = current->next->data;
					current->next->data = swap;

					current = lst;
				}
				else
						current = current->next;
		}
		current = lst;
		return (lst);
}
t_list	*add_int(t_list *list, int nb)
{
	t_list *new;

	new = (t_list*)malloc(sizeof(t_list));
	new->data = nb;
	new->next = list;
	return (new);
}

int		ascending(int a, int b)
{
		return (a <= b);
}

int	main(void)
{
	t_list *list;

	list = NULL;
	list = add_int(list, 9);
	list = add_int(list, 3);
	list = add_int(list, 2);
	list = add_int(list, 4);
	list = add_int(list, 1);
	list = sort_list(list, &ascending);

	while(list != NULL)
	{
		printf("%d\n", list->data);
		list = list->next;
	}
	
	return (0);
}


